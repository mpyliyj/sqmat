# -*- coding: utf-8 -*-
# <nbformat>3.0</nbformat>

# <codecell>

import tesla
import matplotlib.pylab as plt
import numpy as np
import os
import sys
import commands
from numpy import array
from numpy import linalg
import time
import matplotlib
import matplotlib.cm as cm
import matplotlib.mlab as mlab
import matplotlib.pyplot as plt
t0=time.clock()
import jnfdefinition
jfdf=jnfdefinition
import squarematrixdefinition
import pickle
import scipy
from scipy import optimize

sqdf=squarematrixdefinition
global scalex, tol


tol=1e-12

print time.clock()-t0 ,"seconds for import sqdf and jfdf"
t0=time.clock()


def sv(filename,x):
	ff=open(filename,'w')
	pickle.dump(x,ff)
	ff.close()

def rl(filename):
	ff=open(filename)
	xx=pickle.load(ff)
	ff.close()
	return xx


global Vm,U,maxchainlenposition,bKi,norder,powerindex,mlen


def wy0(x,xp,y,yp):
	#given real space x,xp calculate twiss space z=xbar-1j*pbar, then calculate normal form w
	#that is the nonlinear normalized space.
	zxbar,zxbars,zybar,zybars=np.dot(bKi[1:5,1:5], array([x,xp,y,yp]))
	zxsbar=zxbar/scalex
	zxsbars=zxbars/scalex
	zysbar=zybar/scalex
	zysbars=zybars/scalex
	Zs=sqdf.Zcol(zxsbar,zxsbars,zysbar,zysbars,norder,powerindex) #Zs is the zsbar,zsbars, column, here zsbar=zbar/scalex
	wy=np.dot(u,Zs) #w is the invariant we denoted as b0 before. Zs is scaled Z, Z is column of zbar, zbars
	return wy[0]

def wyz(zxbar,zybar):
	#given normalized space xbar,xpbar,ybar,ypbar calculate twiss space z=xbar-1j*pbar, then calculate normal form wy
	#that is the nonlinear normalized space.
	zxbars,zybars=np.conjugate(zxbar),np.conjugate(zybar)
	zxsbar=zxbar/scalex
	zxsbars=zxbars/scalex
	zysbar=zybar/scalex
	zysbars=zybars/scalex
	Zs=sqdf.Zcol(zxsbar,zxsbars,zysbar,zysbars,norder,powerindex) #Zs is the zsbar,zsbars, column, here zsbar=zbar/scalex
  	wz=np.dot(u[0],Zs) #w is the invariant we denoted as b0 before. Zs is scaled Z, Z is column of zbar, zbars
	return wz


		


def zzsexchange(norder,powerindex,sequencenumber,tol):
#zzsexchange is the map to exchange the coordinate z with zs, so its linear part shoul be:z=zs, zs=z
#  z =  0*z +   zs
#  zs=  1*z +  0*zs
	zx=np.zeros(mlen)
	zx[2]=1
	zxs=np.zeros(mlen)
	zxs[1]=1
	zy=np.zeros(mlen)
	zy[4]=1
	zys=np.zeros(mlen)
	zys[3]=1
	zzsm=[zx,zxs,zy,zys]
	zzsexchangem=sqdf.squarematrix(zzsm,norder,powerindex,sequencenumber,tol)
	return zzsexchangem







#1.read saved map matrix M
Ms10,phix0,phiy0,powerindex,norder,bK,bKi,sqrtbetax,sqrtbetay,msf,tbl,scalemf=rl("jfM.dat")
sequencenumber=np.zeros((norder+1,norder+1,norder+1,norder+1),'i')   #sequence number is given as a function of a power index 
powerindex=sqdf.powerindex4(norder)
powerindex=array(powerindex,'i')
mlen=len(powerindex)

for i in range(mlen):
	ip=powerindex[i]
	sequencenumber[ip[0]][ip[1]][ip[2]][ip[3]]=i

mlen=len(Ms10)

norder=7
plen=(norder+1)*(norder+2)*(norder+3)*(norder+4)/24
powerindex=sqdf.powerindex4(norder)
sequencenumber=np.zeros((norder+1,norder+1,norder+1,norder+1),'i')  #sequence number is given as a function of a power index
powerindex=array(powerindex,'i')
mlen=len(powerindex)
Ms10=Ms10[:mlen,:mlen]
bK=bK[:mlen,:mlen]
bKi=bKi[:mlen,:mlen]


for i in range(mlen):
	ip=powerindex[i]
	sequencenumber[ip[0]][ip[1]][ip[2]][ip[3]]=i

mlen=len(Ms10)

#3.Test find Jordan block of eigenvalue m*phx0+n*phiy0
mu=phix0-phiy0
Ms,As2,Asm2,scalex=jfdf.scalingnew(Ms10,powerindex,scalemf) #We no longer use Ms2 as in jf24.py, scalex now include both initial scaling scalemf, and the scaling generated by second scaling 
u,J,vn,un=jfdf.UMexpJnew(Ms,mu,powerindex,1,ypowerorder=7)#Temporarily we still use all the power including y
mn=Ms-np.identity(len(Ms))*np.exp(1j*mu)
tm1,g=jfdf.righteigensubspace(mn)
A=np.dot(u,g)
Am=np.linalg.inv(A)
ubar=np.dot(g,Am)
ypowerorder=7
tmp=[ [k,abs(b)]  for k,b in enumerate(abs(u[0])) if sum(powerindex[k][2:4])<=ypowerorder] #takes only x powers for its index and value in u[0]
#At this point we found in jnfdefinition.py the above line has to be modified to " sum(powerindex[k][2:4])=<ypowerorder" from "sum(powerindex[k][2:4])==0"

uyx,uyxbar,Jyx,scaleyx,Msyx,As2yx,Asm2yx=jfdf.UMsUbarexpJ(Ms10,phix0-phiy0,1,powerindex,scalemf,ypowerorder=7)

def checkjnf(u,J,scale,nx,phix0,ny,phiy0,Ms,info,tol1,tol2):
	print info['sectionname'],". Check u as left eigenvectors of M: U.M=exp(i*mu)*exp(J).U:"
	print info['Jname'],"="
	jfdf.pim(J,len(J),len(J))
	maxchainlenposition, maxchainlen, chain, chainposition=jfdf.findchainposition(Jyx)
	print "position of max length chain=",maxchainlenposition
	print "max length chain=",maxchainlen
	tmp1=np.dot(u,Ms)
	tmp2=np.exp(1j*(nx*phix0+ny*phiy0))*np.dot(jfdf.exp(J,maxchainlen),u)
	tmp3=tmp1-tmp2
	print info['sectionname'],". check ",info['uname'],".",info['Msname'],"=exp(i*",info['muname'],")*exp(",info['Jname'],").",info['uname'], ",", abs(tmp3).max()," relative error:",abs(tmp3).max()/abs(tmp1).max()


	print info['sectionname'],". lowest order in ",info['uname'],"[i]:\n"
	for i in range(len(u)):
		tmp=[ sum(powerindex[k])  for k,b in enumerate(abs(u[i])) if b>1e-8]
		if tmp!=[]: print i, min(tmp)

	def dmt(k,m, tol=tol2): #Dominating terms of k'th order in uy[m]
		dt=[ [i,j,abs(u[m][i])] for i,j in enumerate(powerindex) if (sum(j)==k and abs(u[m][i])>tol2)]
		return dt 

	print "\n",info['sectionname'], ". dominating terms in ",info['uname'],"[0], their order, and size:"
	cc=[ [k,sum(powerindex[k]),b,powerindex[k].tolist()]  for k,b in enumerate(abs(u[0])) if b>tol2]
	for i in cc:
		print i



	print "\n",info['sectionname'],". dominating terms of order 1 in ",info['uname'],"[0] :", [ [j[0],j[1].tolist(),j[2]] for j in dmt(1,0)]
	print info['sectionname'],". dominating terms of order 2 in ",info['uname'],"[0]:", [ [j[1].tolist(),j[2]] for j in dmt(2,0)]
	print info['sectionname'],". dominating terms of order 3 in ",info['uname'],"[0]:",[ [j[1].tolist(),j[2]] for j in dmt(3,0)]

	print info['sectionname'],". Showing the lowest of power of x,y in every eigenvector :"
	for k in range(len(u)):
		tmp=[ sum(j) for i,j in enumerate(powerindex) if  abs(u[k][i])>tol2]
		if tmp!=[]: print "k=",k," lowest order=", min(tmp)
	return

checkjnf(uyx,Jyx,scaleyx,1,phix0,-1,phiy0,Msyx,{'sectionname':'3','Jname':'Jyx','uname':'uyx','Msname':'Msyx','muname':'muyx'},1e-8,1e-5)


#4.Check Jordan block phiy0
uy,uybar,Jy,scaley,Ms,As2,Asm2=jfdf.UMsUbarexpJ(Ms10,phiy0,1,powerindex,scalemf,ypowerorder=7)
checkjnf(uy,Jy,scaley,0,phix0,1,phiy0,Ms,{'sectionname':'4','Jname':'Jy','uname':'uy','Msname':'Msy','muname':'muy'},1e-8,1e-5)



#6. Jordan block for x

uxy,uxybar,Jxy,scalexy,Msxy,As2xy,Asm2xy=jfdf.UMsUbarexpJ(Ms10,2*phiy0,1,powerindex,scalemf,ypowerorder=7)
checkjnf(uxy,Jxy,scalexy,0,phix0,2,phiy0,Msxy,{'sectionname':'5','Jname':'Jxy','uname':'uxy','Msname':'Msxy','muname':'muxy'},1e-8,1e-5)
print "\n6. Check ux as left eigenvectors of M: ux.M=exp(i*mux)*exp(Jx).ux:"

ux,uxbar,Jx,scalex,Ms,As2x,Asm2x=jfdf.UMsUbarexpJ(Ms10,phix0,1,powerindex,scalemf,ypowerorder=7)
checkjnf(ux,Jx,scalex,1,phix0,0,phiy0,Ms,{'sectionname':'6','Jname':'Jx','uname':'ux','Msname':'Ms','muname':'mux'},1e-8,1e-5)


#7 Joined block for x an y
def uxJresonace(Ms10,phix0,phiy0,powerindex,scalemf):
	#Module for Jordan form of combined resonance blocks, developed in jf27.py
	ux,uxbar,Jx,scalex,Ms,As2x,Asm2x=jfdf.UMsUbarexpJ(Ms10,phix0,1,powerindex,scalemf,ypowerorder=7)
	uxy,uxybar,Jxy,scalexy,Msxy,As2xy,Asm2xy=jfdf.UMsUbarexpJ(Ms10,2*phiy0,1,powerindex,scalemf,ypowerorder=7) #See nsls2yongjun.pptx, p.4, 2Qy resonant with Qx.
#	u1,u1bar,J1,scalex1,Ms1,As1,Asm1=jfdf.UMsUbarexpJ(Ms10,phix0,nres1,powerindex,scalemf,ypowerorder=0)
#	u4,u4bar,J4,scalex4,Ms4,As4,Asm4=jfdf.UMsUbarexpJ(Ms10,phix0,nres2,powerindex,scalemf,ypowerorder=0)
#	u6,u4bar,J6,scalex6,Ms6,As6,Asm6=jfdf.UMsUbarexpJ(Ms10,phix0,nres3,powerindex,scalemf,ypowerorder=0)
	uyx=jfdf.d3(uxy,As2xy,Asm2x) #see M scaling in Jordan form reformulation.one

	#u6=jfdf.d3(u6,As6,Asm1) #U.M.Ubar=u.As.M.Asm.ubar=u.Ms.ubar=exp(i*phi0+J), so U=u.As
	#So u41.As41=u42.As42=U4, so u41=u42.As42.Asm41 when we have scaled one block u42 using As42, and
	#we want use scaling As41(=As1) to scale to u41, then for rescaling we use u41=u42.As42.Asm41
	#So u4=u41.As41.Asm1.
	#both Jx and Jxy have chain structure as  [[0, 1, 2, 3], [4, 5, 6], [7, 8], [9]] and [[0, 1, 2], [3, 4], [5]], so when taking only first chain, the joined block has length 4+3
	J0=np.zeros([4+3,4+3])
	J0[:4,:4]=Jx[:4,:4]
	J0[4:7,4:7]=Jxy[:3,:3]
	U=np.vstack([ux[:4],uxy[:3]])
	maxchainlenposition, maxchainlen, chain, chainposition=jfdf.findchainposition(J0)
	u,G=jfdf.minimizeu0byordernew(U,J0,chainposition, powerindex,ypowerorder=7)
	return u, J0, G, Ms, scalex

ux, Jx, G, Msx, scalex=uxJresonace(Ms10,phix0,phiy0,powerindex,scalemf)



def uyJresonace(Ms10,phix0,phiy0,powerindex,scalemf):
	#Module for Jordan form of combined resonance blocks, developed in jf27.py
	uy,uybar,Jy,scaley,Msy,Asy,Asmy=jfdf.UMsUbarexpJ(Ms10,phiy0,1,powerindex,scalemf,ypowerorder=7)
	uyx,uyxbar,Jyx,scaleyx,Msyx,Asyx,Asmyx=jfdf.UMsUbarexpJ(Ms10,phix0-phiy0,1,powerindex,scalemf,ypowerorder=7)
#	u1,u1bar,J1,scalex1,Ms1,As1,Asm1=jfdf.UMsUbarexpJ(Ms10,phix0,nres1,powerindex,scalemf,ypowerorder=0)
#	u4,u4bar,J4,scalex4,Ms4,As4,Asm4=jfdf.UMsUbarexpJ(Ms10,phix0,nres2,powerindex,scalemf,ypowerorder=0)
#	u6,u4bar,J6,scalex6,Ms6,As6,Asm6=jfdf.UMsUbarexpJ(Ms10,phix0,nres3,powerindex,scalemf,ypowerorder=0)
	uyx=jfdf.d3(uyx,Asyx,Asmy) #see M scaling in Jordan form reformulation.one

	#u6=jfdf.d3(u6,As6,Asm1) #U.M.Ubar=u.As.M.Asm.ubar=u.Ms.ubar=exp(i*phi0+J), so U=u.As
	#So u41.As41=u42.As42=U4, so u41=u42.As42.Asm41 when we have scaled one block u42 using As42, and
	#we want use scaling As41(=As1) to scale to u41, then for rescaling we use u41=u42.As42.Asm41
	#So u4=u41.As41.Asm1.
	#both Jy and Jyx have chain structure as  [[0, 1, 2, 3], [4, 5, 6], [7, 8], [9]] and [[0, 1, 2], [3, 4], [5]], so when taking only first chain, the joined block has length 4+3
	J0=np.zeros([4+3,4+3])
	J0[:4,:4]=Jy[:4,:4]
	J0[4:7,4:7]=Jyx[:3,:3]
	U=np.vstack([uy[:4],uyx[:3]])
	maxchainlenposition, maxchainlen, chain, chainposition=jfdf.findchainposition(J0)
	u,G=jfdf.minimizeu0byordernew(U,J0,chainposition, powerindex,ypowerorder=7)
	return u, J0, G, Msy, scaley

uy, Jy, G, Msy, scaley=uyJresonace(Ms10,phix0,phiy0,powerindex,scalemf)


#7. Plot tracking result 
print "\n7. Tracking x,y motion"
flnm=open('beamsddstail','w')
npart=1
flnm.write('%10i \n'%npart)
xmax=2e-3
ymax=2e-3
npass=257 #8193
xxp0=[]
p_central_mev=3000
x0off=0e-7  #it is found that there is an round off error in elegant that causes residual energy delta non-zero and caused an offset for x0 and xp0
xp0off=0e-10 #which is to be removed here for Jordan form calculation. This offsets are found when we reduce the radius in w plane, the circle in the 
#zbar plane in the following calculation has a center which is shift away from origin.
x0=xmax+x0off
xp0=0+xp0off
y0=ymax
pid=1
#write into input file for elegant x0,xp0 for all particles of different theta0
#flnm.write('%10.6g %10.6g %10.6g %10.6g %10.6g %10.6g %10.6g %10i \n'%(x0,xp0,0,0,0,5.870852e+03,0,pid))
flnm.write('%10.6g %10.6g %10.6g %10.6g %10.6g %10.6g %10.6g %10i \n'%(x0,xp0,y0,0,0,p_central_mev/0.511,0,pid))
flnm.close()
os.system('cat beamsddshead beamsddstail >beam.sdds')
os.system('elegant  -macro=npass='+str(npass)+'   tracking.ele')
ta, xxp=commands.getstatusoutput('sddsprocess ring.w1 -filter=col,Pass,1,'+str(npass)+' -pipe=out|sddsprintout -pipe=in -col="(Cx,Cxp,Cy,Cyp)" -noLabel -noTitle ') #read output of elegant for x,xp after one turn
import StringIO
from StringIO import StringIO
xxp = StringIO(xxp) #retrieve from elegant output file as string, and change the string into a virtual file
xxp=np.loadtxt(xxp) #load the virtual file to convert it into an array of x,xp after 1 turn
xxpyyp=zip(*xxp)

ta, tune=commands.getstatusoutput("sddsexpand ring.w1 -pipe=out|sddscollapse -pipe=input,output|sddsnaff -pipe=in,out -col=Pass,Cx,Cy -term=frequencies=3 |sddsprintout -pipe=in -col") #='(xFrequency,yFrequency)' ")
print "tune x,y are:",tune

#8. Convert x,xp,y,yp to zx,zxs,zy,zys, i.e., to nomalized coordinates
from scipy import loadtxt
import StringIO
from StringIO import StringIO
ta,nsls2twis=commands.getstatusoutput('sddsprintout nsls2yongjun.twi -col="(betax,alphax,psix,betay,alphay,psiy)" -noLabel -noTitle|tail -1') #read output of elegant for x,xp after one turn
nsls2twis = StringIO(nsls2twis) #retrieve from elegant output file as string, and change the string into a virtual file
betaxelegant,alphaxelegant,phixelegant,betayelegant,alphayelegant,phiyelegant=loadtxt(nsls2twis) #load the virtual file to convert it into an array of x,xp after 1 turn
sqrtbxelegant=np.sqrt(betaxelegant)
sqrtbyelegant=np.sqrt(betayelegant)
Bielegant=array([[1/sqrtbxelegant,0,0,0],[alphaxelegant/sqrtbxelegant,sqrtbxelegant,0,0], #Bi converts x,xp,y,yp to xbar,xpbar,ybar,ypbar see SY.Lee's book, Floquet trsansform II.3 eq2.43
[0,0,1/sqrtbyelegant,0],[0,0,alphayelegant/sqrtbyelegant,sqrtbyelegant]])
Ki=array([[1,-1j,0,0],[1,1j,0,0],[0,0,1,-1j],[0,0,1,1j]]) #For Ki see Courant-Snyder variables and U transform and relation to Twiss Transform.one 12/16/2009
bKielegant=np.dot(Ki,Bielegant)
xybar=np.dot(Bielegant,xxpyyp)

'''
# tested by YJ
plt.figure()
plt.plot(xybar[0],xybar[1],'.')
plt.axis('equal')
plt.savefig('xybar_ele.png')
plt.close()
'''

import cmath


#9. study Poincare section plot using |zy|,phix,phiy
print "\n9. study Poincare section plot using |zy|,phix,phiy"

def normalcoordinate(xb,xpb,yb,ypb): #Calculate action w for given x,xp, and the theoretical first order tune shift in w-plane as function of x,xp
	#See note "Relation to driving terms/Jordan Form Reformulation/Amplitude dependent tune", section 8, 2/19/2015
	#For tune with 5 phix0 close to 2 pi, block 1, -4, 6 are used
	zxb=xb-1j*xpb
	ab0x=xb**2+xpb**2
	phib0x=cmath.phase(zxb)
	zyb=yb-1j*ypb
	ab0y=yb**2+ypb**2
	phib0y=cmath.phase(zyb)
   	return ab0x,ab0y,phib0x,  phib0y

section=[]
xy=zip(*xybar)
for row in xy:
	section.append(normalcoordinate(*row))

tmp=zip(*section)
#YJtmp = np.array(tmp)
Jylim=max(tmp[1])*1.1

fig=plt.figure(91) #phiy vz Jyb for various phiy
for i in range(1,8):
	plt.subplot(2,4, i)
	stnarrow=zip(*[ row for row in section if abs(row[3]-4.0+i)<1e-1])
	plt.plot(stnarrow[2],stnarrow[1],'.') #phix vz Jyb
	plt.axis([-4,4,0.5*Jylim,Jylim])
	plt.xlabel('phix')
	plt.ylabel('|Jy|')
	plt.title('phiy='+str(-4+i))

txt = fig.text(0.452, 0.95, 'Fig.10 |Jy| vz. phi_x for different phi_y', fontsize = 18)

fig=plt.figure(92) #phiy vz Jyb for various phiy
for i in range(1,8):
	plt.subplot(2,4, i)
	stnarrow=zip(*[ row for row in section if abs(row[2]-4.0+i)<1e-1])
	plt.plot(stnarrow[3],stnarrow[1],'.') #phix vz Jyb
	plt.axis([-4,4,0.5*Jylim,Jylim])
	plt.xlabel('phiy')
	plt.ylabel('|Jy|')
	plt.title('phix='+str(-4+i))

txt = fig.text(0.452, 0.95, 'Fig.11 |Jy| vz. phi_y for different phi_x', fontsize = 18)

st=zip(*section)
sv('junk',st)

zmax=max(st[0])
zmin=min(st[0])
zav=np.mean(st[0])
print " for Jx,  (zmax-zmin)/zmean=",(zmax-zmin)/zav

zmax=max(st[1])
zmin=min(st[1])
zav=np.mean(st[1])
print " for Jy,  (zmax-zmin)/zmean=",(zmax-zmin)/zav


#10. Study the change of wy after one turn for a fixed x,xp and fixed initial wy.
def tuneshift(x,xp,y,yp,ux,uy): #Calculate action w for given x,xp, and the theoretical first order tune shift in w-plane as function of x,xp
	#See note "Relation to driving terms/Jordan Form Reformulation/Amplitude dependent tune", section 8, 2/19/2015
	#For tune with 5 phix0 close to 2 pi, block 1, -4, 6 are used
	zxbar,zxbars,zybar,zybars=np.dot(bKielegant, array([x,xp,y,yp]))
	zxsbar=zxbar/scalex
	zxsbars=zxbars/scalex
	zysbar=zybar/scalex
	zysbars=zybars/scalex
	Zxs=sqdf.Zcol(zxsbar,zxsbars,zysbar,zysbars,norder,powerindex) #Zxs is the zsbar,zsbars, column, here zsbar=zbar/scalex
	zxsbar=zxbar/scaley
	zxsbars=zxbars/scaley
	zysbar=zybar/scaley
	zysbars=zybars/scaley
	Zys=sqdf.Zcol(zxsbar,zxsbars,zysbar,zysbars,norder,powerindex) #Zys is the zsbar,zsbars, column, here zsbar=zbar/scaley
	wx=np.dot(ux,Zxs) #Zxs is used for wx while Zys is used for wy, separately!
	b0x=wx[0]
	dmu00x=-1j*(wx[1])/b0x
	ab0x=abs(b0x)
	phib0x=cmath.phase(b0x)
	wy=np.dot(uy,Zys)
	b0y=wy[0]
	dmu00y=-1j*(wy[1])/b0y
	ab0y=abs(b0y)
	phib0y=cmath.phase(b0y)
   	return ab0x,ab0y, phib0x, phib0y
#   	return np.real(b0x), np.imag(b0x)

#11. Prepare data for |wx|,thetax,|wy|,thetay to plot Poincare section of thetax,|wy|,thetay
ux1,uxbar,Jx,scalex,Ms,As2x,Asm2x=jfdf.UMsUbarexpJ(Ms10,phix0,1,powerindex,scalemf,ypowerorder=7)
uy1,uybar,Jy,scaley,Ms,As2,Asm2=jfdf.UMsUbarexpJ(Ms10,phiy0,1,powerindex,scalemf,ypowerorder=7)

uy2, Jy, G, Msy, scaley=uyJresonace(Ms10,phix0,phiy0,powerindex,scalemf)
ux2, Jx, G, Msx, scalex=uxJresonace(Ms10,phix0,phiy0,powerindex,scalemf)

section1=[] #section1 is without joined blocks
xy=zip(*xxpyyp)
for row in xy:
	row1=row+(ux1,uy1)
	section1.append(tuneshift(*row1))

section2=[] #section2 is with joined blocks
xy=zip(*xxpyyp)
for row in xy:
	row1=row+(ux2,uy2)
	section2.append(tuneshift(*row1))

st1=zip(*section1)
st2=zip(*section2)

#plt.figure(111)
#plt.plot(st[3],st[1],'.') #phiy vz Jy
#plt.axes().set_aspect('equal')
#plt.figure(112)
#plt.plot(st[2],st[1],'.')#phix vz. Jx

sv('junk1',st1)
zmax=max(st1[0])
zmin=min(st1[0])
zav=np.mean(st1[0])
print " for wx1 without resonance block,  (zmax-zmin)/zmean=",(zmax-zmin)/zav

zmax=max(st1[1])
zmin=min(st1[1])
zav=np.mean(st1[1])
print " for wy1 without resonance block,  (zmax-zmin)/zmean=",(zmax-zmin)/zav

sv('junk2',st2)
zmax=max(st2[1])
zmin=min(st2[1])
zav=np.mean(st2[1])
print " for wy2 with resonance block,  (zmax-zmin)/zmean=",(zmax-zmin)/zav


sys.exit(0)

